import { useState, useEffect } from "react";

// ---------------------------------------------------------------------------
// SpellingChallenge Component (src/components/SpellingChallenge.tsx)
// ---------------------------------------------------------------------------
// Contains the primary gameplay loop of the application. It receives a range of
// word indices and walks the player through spelling them one by one. Correct
// answers award XP, hints and Pokémon, while wrong answers give feedback and
// allow retries. The component purposely keeps data fetching and persistence
// logic outside so it can be easily unit tested and reused in potential future
// game modes.
import wordsWithPronunciations from "@/data/words_with_pronunciations.json";
import pokemon from "@/data/pokemon.json";
import scenes from "@/data/scenes.json";
//
// Development Plan:
// - Split large pieces of logic (input handling, progress calculation,
//   pronunciation lookup) into custom hooks to keep this component easier to
//   maintain.
// - Replace hard-coded XP values with constants configurable via `settings.json`
//   so tuning the reward curve doesn't require code changes.
// - Consider adding unit tests for the core functions here using React Testing
//   Library once the project has a test runner.
// - Document how hints are awarded and consumed in gameState.ts so new gameplay
//   modes can integrate with the same mechanics.
// - Investigate persisting partially completed scenes so children can resume
//   where they left off after closing the browser.
import Controls from "./Controls";
import OnScreenKeyboard from "./OnScreenKeyboard";
import ProgressBar from "./ProgressBar";
import { speak } from "@/services/ttsService";
import { useGameStore } from "@/services/gameState";
import {
  Alert,
  Box,
  Button,
  Card,
  CardContent,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  TextField,
  Typography,
  Divider,
} from "@mui/material";

// Each word in `words_with_pronunciations.json` includes a pronunciation for the
// text-to-speech service. Wrapping the data in this interface keeps the logic
// explicit while still allowing words to be simple strings when the
// pronunciation matches the spelling.
interface WordEntry {
  word: string;
  pronunciation?: string;
  index: number;
}

// Define the shake animation keyframes
const shakeAnimation = `
  @keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
    40%, 60% { transform: translate3d(4px, 0, 0); }
  }
`;

interface SpellingChallengeProps {
  wordStart: number;
  wordEnd: number;
}

export default function SpellingChallenge({
  wordStart,
  wordEnd,
}: SpellingChallengeProps) {
  const [sceneWords, setSceneWords] = useState<WordEntry[]>([]);
  const [currentWordIndex, setCurrentWordIndex] = useState(0);
  const [currentInput, setCurrentInput] = useState("");
  const [message, setMessage] = useState("");
  const [lastCaughtPokemon, setLastCaughtPokemon] = useState<{
    id: number;
    name: string;
    sprite: string;
  } | null>(null);
  const [isCatchDialogOpen, setCatchDialogOpen] = useState(false);
  const [isShaking, setIsShaking] = useState(false); // State for shake animation
  const [isAnswered, setIsAnswered] = useState(false); // State to disable form

  const {
    xp,
    level,
    xpToNextLevel,
    hintCharges,
    masteredWordIndices,
    collectedPokemonIds,
    spendHint,
    addXp,
    catchPokemon,
    incrementWordsMastered,
    completeScene,
  } = useGameStore();

  const scene = scenes.find(
    (s) => s.word_start === wordStart && s.word_end === wordEnd,
  );
  const sceneId = scene?.id;
  const currentWordObject = sceneWords[currentWordIndex];
  const currentWord = currentWordObject?.word;

  const xpForLastLevel = (level - 1) * 100;
  const xpGainedThisLevel = xp - xpForLastLevel;
  const xpNeededForThisLevel = xpToNextLevel - xpForLastLevel;

  useEffect(() => {
    // When the scene changes we slice out the relevant words along with their
    // pronunciations generated by `build_pronunciations.py`. Previously mastered
    // words are filtered out so they don't appear again.
    const wordsForScene: WordEntry[] = wordsWithPronunciations
      .slice(wordStart, wordEnd + 1)
      .map((w, i) => ({ ...w, index: wordStart + i }))
      .filter((w) => !masteredWordIndices.includes(w.index));
    setSceneWords(wordsForScene);
    setCurrentWordIndex(0);
    setCurrentInput("");
    setMessage("");
    setLastCaughtPokemon(null);
    setIsAnswered(false); // Reset on new scene
  }, [wordStart, wordEnd, masteredWordIndices]);

  useEffect(() => {
    // Speak the current word every time it changes. This keeps the game
    // accessible for younger players who may rely on auditory cues.
    if (currentWordObject) {
      speak(currentWordObject.word, currentWordObject.pronunciation);
    }
  }, [currentWordObject]);

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = event.target.value.replace(/[^a-zA-Z]/g, "").toLowerCase();
    if (currentWord && newValue.length > currentWord.length) {
      return;
    }
    setCurrentInput(newValue);
  };

  const handleKeyboardInput = (char: string) => {
    if (currentWord && currentInput.length < currentWord.length) {
      setCurrentInput((prev) => (prev + char).slice(0, currentWord.length));
    }
  };

  const handleBackspace = () => {
    setCurrentInput((prev) => prev.slice(0, -1));
  };

  const handleRepeat = () => {
    if (currentWordObject) {
      speak(currentWordObject.word, currentWordObject.pronunciation);
    }
  };

  const handleSubmit = (e?: React.FormEvent<HTMLFormElement>) => {
    if (e) e.preventDefault();
    // Ignore submissions if the user has not typed anything or if the current
    // word has already been marked as answered (prevents double rewards).
    if (!currentInput || isAnswered) return;

    if (currentInput.toLowerCase() === currentWord?.toLowerCase()) {
      // Correct answer: reward the player and move forward.
      setIsAnswered(true); // Disable form
      addXp(10);
      if (currentWordObject) {
        incrementWordsMastered(currentWordObject.index);
      }

      const scenePokemon = pokemon.filter((p) => p.scene_id === sceneId);
      const nextPokemonToCatch = scenePokemon.find(
        (p) => !collectedPokemonIds.includes(p.id),
      );

      if (nextPokemonToCatch) {
        catchPokemon(nextPokemonToCatch.id);
        setLastCaughtPokemon({
          id: nextPokemonToCatch.id,
          name: nextPokemonToCatch.name,
          sprite: nextPokemonToCatch.sprite,
        });
        setCatchDialogOpen(true);
      } else {
        setMessage("Correct! 🎉");
      }
    } else {
      // Wrong answer feedback: briefly shake the input box and show a message.
      setMessage("Try again!");
      setIsShaking(true);
      setTimeout(() => setIsShaking(false), 820); // Reset shake after animation
    }
  };

  const handleNextWord = () => {
    if (currentWordIndex < sceneWords.length - 1) {
      setCurrentWordIndex(currentWordIndex + 1);
      setCurrentInput("");
      setMessage("");
      setLastCaughtPokemon(null);
      setIsAnswered(false); // Re-enable form for next word
    } else {
      setMessage("You have completed all the words in this scene! 🏆");
      if (sceneId) {
        completeScene(sceneId);
      }
      setCurrentInput("");
      setLastCaughtPokemon(null);
      setIsAnswered(true); // Keep form disabled at the end
    }
  };

  const handleCloseCatchDialog = () => {
    setCatchDialogOpen(false);
    handleNextWord();
  };

  const handleHint = () => {
    // Only provide a hint if we have charges remaining and the user has not
    // already filled out the entire word. This prevents hints from going beyond
    // the word's length.
    if (
      hintCharges <= 0 ||
      !currentWord ||
      currentInput.length >= currentWord.length
    ) {
      return;
    }
    const nextChar = currentWord[currentInput.length];
    setCurrentInput(currentInput + nextChar);
    spendHint();
  };

  if (sceneWords.length === 0) {
    return (
      <Typography>You have mastered all words in this scene! 🎉</Typography>
    );
  }

  if (!currentWordObject || !currentWord) {
    return <Typography>Loading challenge...</Typography>;
  }

  const wordBlanks = currentWord.split("").map((_, index) => (
    <span key={index}>
      {currentInput[index] ? currentInput[index].toUpperCase() : "_"}
    </span>
  ));

  // Rendering below is intentionally verbose so that the UI can be customized
  // without digging into complex component abstractions. It is easier for new
  // contributors to adjust spacing or styles when the markup is laid out here
  // instead of hidden in a separate component tree.

  return (
    <>
      <style>{shakeAnimation}</style> {/* Inject keyframes into the document */}
      <Card>
        <CardContent sx={{ p: { xs: 2, sm: 3 } }}>
          {/* Status Bar, etc. */}
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 2,
            }}
          >
            <Box sx={{ textAlign: "center" }}>
              <Typography variant="caption" color="text.secondary">
                LEVEL
              </Typography>
              <Typography variant="h5" component="div">
                {level}
              </Typography>
            </Box>
            <Box sx={{ width: "40%" }}>
              <ProgressBar
                current={xpGainedThisLevel}
                total={xpNeededForThisLevel}
              />
            </Box>
            <Box sx={{ textAlign: "center" }}>
              <Typography variant="caption" color="text.secondary">
                HINTS
              </Typography>
              <Typography variant="h5" component="div">
                {hintCharges}
              </Typography>
            </Box>
          </Box>

          <Divider sx={{ my: 2 }} />
          {/* Spelling Area */}
          <Box component="form" onSubmit={handleSubmit} sx={{ textAlign: "center" }}>
            <Typography variant="h6" gutterBottom>
              Spell the word:
            </Typography>

            <Typography
              variant="h4"
              component="div"
              sx={{
                fontFamily: "monospace",
                letterSpacing: { xs: "0.5em", sm: "1em" },
                my: 3,
                fontSize: { xs: "1.5rem", sm: "2.125rem" },
              }}
            >
              {wordBlanks}
            </Typography>

            <TextField
              value={currentInput.toUpperCase()}
              onChange={handleInputChange}
              autoFocus
              autoComplete="off"
              variant="outlined"
              disabled={isAnswered} // Disable based on state
              sx={{ // Apply animation conditionally
                mb: 2,
                width: "100%",
                maxWidth: "300px",
                animation: isShaking ? "shake 0.82s" : "none",
              }}
              inputProps={{
                style: {
                  textAlign: "center",
                  fontSize: "2rem",
                  letterSpacing: "0.2em",
                  padding: "10px",
                },
                maxLength: currentWord.length,
              }}
            />

            <OnScreenKeyboard
              onKey={handleKeyboardInput}
              onBackspace={handleBackspace}
            />

            {/* Feedback Message */}
            <Box
              sx={{
                height: 90,
                mt: 2,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
              }}
            >
              {message && !message.startsWith("Correct") && (
                <Alert
                  severity={message.includes("completed") ? "success" : "info"}
                >
                  {message}
                </Alert>
              )}
            </Box>

            {/* Action Buttons */}
            {isAnswered && !isCatchDialogOpen ? (
              <Button
                variant="contained"
                onClick={handleNextWord}
                sx={{ width: "100%", maxWidth: "300px" }}
              >
                Next Word
              </Button>
            ) : (
              <Controls
                onSubmit={handleSubmit}
                onHint={handleHint}
                onRepeat={handleRepeat}
                hintDisabled={hintCharges <= 0 || isAnswered}
                submitDisabled={isAnswered}
              />
            )}
          </Box>
        </CardContent>
      </Card>

      {/* Pokémon Caught Dialog */}
      <Dialog open={isCatchDialogOpen} onClose={handleCloseCatchDialog}>
        <DialogTitle sx={{ textAlign: 'center', fontWeight: 'bold' }}>
          You caught a {lastCaughtPokemon?.name}!
        </DialogTitle>
        <DialogContent sx={{ textAlign: 'center' }}>
          <img
            src={`/assets/images/pokemon/${String(lastCaughtPokemon?.id).padStart(3, "0")}.png`}
            alt={lastCaughtPokemon?.name}
            style={{
              width: "100%",
              maxWidth: "250px",
              margin: "auto",
            }}
          />
        </DialogContent>
        <DialogActions sx={{ justifyContent: 'center', pb: 2 }}>
          <Button onClick={handleCloseCatchDialog} variant="contained" autoFocus>
            Continue
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
}